// RUN: %target-sil-opt -enable-objc-interop -enforce-exclusivity=none -enable-sil-verify-all %s -jumpthread-simplify-cfg
//
// These tests case are converted to OSSA form, but aren't yet
// optimized in OSSA mode. Move them to one of these files when
// they are enabled:
// - simplify_cfg_ossa.sil
// - simplify_cfg_simplejumpthread.sil
// - simplify_cfg_checkcast.sil
// - simplify_cfg_domjumpthread.sil
//

sil_stage canonical

import Builtin
import Swift

class C {
  final var value: Int32
  init(v: Int32)
}


struct FakeBool {
  @_hasStorage var value: Builtin.Int1 { get set }
  init(value: Builtin.Int1)
}

enum BoolLike { case true_, false_ }

enum OneCase {
  case First
}

class Klass {}

sil [ossa] @external_f : $@convention(thin) () -> ()


// TODO: Support redundancy looking through copy_values
// TCHECK-LABEL: sil [ossa] @redundant_switchenum_owned :
// TCHECK: bb1:
// TCHECK:  br [[DEST:[a-zA-Z0-9]+]]
// TCHECK: bb2:
// TCHECK: br [[DEST]]
// TCHECK: [[DEST]]({{.*}}):
// TCHECK-NOT: cond_br
// TCHECK: return
// TCHECK-NOT: bb4:
// TCHECK-NOT: switch_enum
sil [ossa] @redundant_switchenum_owned : $@convention(thin) (@owned Optional<C>) -> Int32 {
bb0(%0 : @owned $Optional<C>):
  %1 = copy_value %0 : $Optional<C>
  switch_enum %1 : $Optional<C>, case #Optional.some!enumelt: bb1, case #Optional.none!enumelt: bb2

bb1(%1b : @owned $C):
  destroy_value %1b : $C
  %9 = integer_literal $Builtin.Int1, -1
  %10 = struct $Bool (%9 : $Builtin.Int1)
  br bb3(%10 : $Bool)

bb2:
  %17 = integer_literal $Builtin.Int1, 0
  %18 = struct $Bool (%17 : $Builtin.Int1)
  br bb3(%18 : $Bool)

bb3(%12 : $Bool):
  %15 = struct_extract %12 : $Bool, #Bool._value
  cond_br %15, bb4, bb7

bb4:
  %21 = alloc_stack $Optional<C>
  %0b = copy_value %0 : $Optional<C>
  store %0b to [init] %21 : $*Optional<C>
  %0c = copy_value %0 : $Optional<C>
  switch_enum %0c : $Optional<C>, case #Optional.some!enumelt: bb5, case #Optional.none!enumelt: bb6

bb5(%0cC : @owned $C):
  destroy_value %0cC : $C
  %25 = unchecked_take_enum_data_addr %21 : $*Optional<C>, #Optional.some!enumelt
  %26 = load [take] %25 : $*C
  dealloc_stack %21 : $*Optional<C>
  %26a = begin_borrow %26 : $C
  %29 = ref_element_addr %26a : $C, #C.value
  %30 = load [trivial] %29 : $*Int32
  end_borrow %26a : $C
  destroy_value %26 : $C
  br bb8(%30 : $Int32)

bb6:
  %34 = builtin "int_trap"() : $()
  unreachable

bb7:
  %36 = integer_literal $Builtin.Int32, 0
  %37 = struct $Int32 (%36 : $Builtin.Int32)
  br bb8(%37 : $Int32)

bb8(%39 : $Int32):
  destroy_value %0 : $Optional<C>
  return %39 : $Int32
}

// TODO: Support the following two cases in SimplifyCFG::simplifyArgument
// TCHECK-LABEL: sil [ossa] @unpack_enum_arg_non_trivial_guaranteed :
// TCHECK: bb1:
// TCHECK:   [[ENUM1:%[0-9]+]] = enum $Optional<Klass>, #Optional.some!enumelt, %0 : $Klass
// TCHECK:   [[BORROW1:%[0-9]+]] = begin_borrow [[ENUM1]] : $Klass
// TCHECK:   br bb3([[BORROW1]] : $Klass)
// TCHECK: bb2:
// TCHECK:   [[ENUM2:%[0-9]+]] = enum $Optional<Klass>, #Optional.some!enumelt, %1 : $Klass
// TCHECK:   [[BORROW2:%[0-9]+]] = begin_borrow [[ENUM2]] : $Klass
// TCHECK:   br bb3([[BORROW2]] : $Klass)
// TCHECK: bb3([[A:%[0-9]+]] : @guaranteed $Klass):
// TCHECK:   return [[A]]
sil [ossa] @unpack_enum_arg_non_trivial_guaranteed : $@convention(thin) (@guaranteed Klass, @guaranteed Klass) -> @owned Klass {
bb0(%0 : @guaranteed $Klass, %1 : @guaranteed $Klass):
  cond_br undef, bb1, bb2

bb1:
  %2 = enum $Optional<Klass>, #Optional.some!enumelt, %0 : $Klass
  %2a = begin_borrow %2 : $Optional<Klass>
  br bb3(%2a : $Optional<Klass>)

bb2:
  %3 = enum $Optional<Klass>, #Optional.some!enumelt, %1 : $Klass
  %3a = begin_borrow %3 : $Optional<Klass>
  br bb3(%3a : $Optional<Klass>)

bb3(%4 : @guaranteed $Optional<Klass>):
  %5 = unchecked_enum_data %4 : $Optional<Klass>, #Optional.some!enumelt
  %5a = copy_value %5 : $Klass
  end_borrow %4 : $Optional<Klass>
  return %5a : $Klass
}

// TCHECK-LABEL: sil [ossa] @unpack_enum_arg_non_trivial_guaranteed_load_borrow :
// TCHECK: bb1:
// TCHECK:   br bb3({{%.*}} : $Klass)
// TCHECK: bb2:
// TCHECK:   br bb3({{%.*}} : $Klass)
// TCHECK: bb3([[A:%[0-9]+]] : @owned $Klass):
// TCHECK:   return [[A]]
sil [ossa] @unpack_enum_arg_non_trivial_guaranteed_load_borrow : $@convention(thin) (@in_guaranteed Klass, @in_guaranteed Klass) -> @owned Klass {
bb0(%0 : $*Klass, %1 : $*Klass):
  %0a = load_borrow %0 : $*Klass
  %1a = load_borrow %1 : $*Klass
  cond_br undef, bb1, bb2

bb1:
  %2 = enum $Optional<Klass>, #Optional.some!enumelt, %0a : $Klass
  %2a = begin_borrow %2 : $Optional<Klass>
  br bb3(%2a : $Optional<Klass>)

bb2:
  %3 = enum $Optional<Klass>, #Optional.some!enumelt, %1a : $Klass
  %3a = begin_borrow %3 : $Optional<Klass>
  br bb3(%3a : $Optional<Klass>)

bb3(%4 : @guaranteed $Optional<Klass>):
  %5 = unchecked_enum_data %4 : $Optional<Klass>, #Optional.some!enumelt
  %5a = copy_value %5 : $Klass
  end_borrow %4 : $Optional<Klass>
  end_borrow %1a : $Klass
  end_borrow %0a : $Klass
  return %5a : $Klass
}
